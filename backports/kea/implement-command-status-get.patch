From 4664dc9539bd4955b869cb8492a5a408fff96bbc Mon Sep 17 00:00:00 2001
From: Francis Dupont <fdupont@isc.org>
Date: Thu, 5 Dec 2019 15:48:02 +0100
Subject: [PATCH] [#1041] Implement command status-get

This patch combines the following commits from
https://gitlab.isc.org/isc-projects/kea/merge_requests/618:

[#1041] Checkpoint: created status-get returning pid (only)

[#1041] Checkpoint: added uptime, last commit and HA to do

[#1041] Checkpoint: added HA state, reload time to do

[#1041] Checkpoint: fixed and improved HA, reload time todo

[#1041] Checkpoint: added reload, doc to do

[#1041] Added getLastCommitTime unit test

[#1041] Added doc skeleton

[#1041] Added HA command processed test

[#1041] Augmented HA report

[#1041] Doc improvements

[#1041] Added more HA doc

[#1041] Added some commandProcessed checks in HA service tests

[#1041] Addressed new comments

[#1041] Checkpoint: moved uptime/reload to libprocess

[#1041] Checkpoint: CA updated

[#1041] Updated d2 (netconf has no control channel)

[#1041] Extended statusGet unittests

The uptime, reload and pid returned are validated.

[#1041] Corrected kea-shell test

This test did not expect the status-get command to be included in respose
to the list-commands.

[#1041] Renamed status get handler in HA

The new name is processStatusGet instead of generic commandProcessed

[#1041] Use isEquivalent in statusGet unittest

[#1041] HA heartbeat response includes scopes

[#1041] Several improvements to status-get (HA)

- Included boolean parameter in-touch to indicate if the status has been
  actually received from the partner.
- Renamed last-known-status (scopes) to last-status (scopes) which is
  shorter.
- Always include all parameters in the status-get response, even if they
  are not set to anything meaningful.
- Return partner's scopes in the response to status-get.

[#1041] Updated docs about status-get

Added new HA specific section too.

[#1041] Added age into the status-get response

[#1041] Added age value to the status-get response

diff --git a/doc/sphinx/api-files.txt b/doc/sphinx/api-files.txt
index 38f39bbc84..83e255a57c 100644
--- a/doc/sphinx/api-files.txt
+++ b/doc/sphinx/api-files.txt
@@ -141,6 +141,7 @@ api/statistic-sample-age-set-all.json
 api/statistic-sample-age-set.json
 api/statistic-sample-count-set-all.json
 api/statistic-sample-count-set.json
+api/status-get.json
 api/stat-lease4-get.json
 api/stat-lease6-get.json
 api/subnet4-add.json
diff --git a/doc/sphinx/api/status-get.json b/doc/sphinx/api/status-get.json
new file mode 100644
index 0000000000..66926830d2
--- /dev/null
+++ b/doc/sphinx/api/status-get.json
@@ -0,0 +1,48 @@
+{
+    "avail": "1.7.3",
+    "brief": [
+        "This command returns server's runtime information.",
+        "It takes no arguments."
+    ],
+    "cmd-syntax": [
+        "{",
+        "    \"command\": \"status-get\"",
+        "}"
+    ],
+    "description": "See <xref linkend=\"command-status-get\"/>",
+    "name": "status-get",
+    "resp-comment": [
+        "If the libdhcp_ha (High Availability) hooks library is loaded by the DHCP server receiving this command the response also includes the HA specific status information of the server receiving the command and its partner's status."
+    ],
+    "resp-syntax": [
+        "{",
+        "    \"result\": <integer>,",
+        "    \"arguments\": {",
+        "        \"pid\": <integer>,",
+        "        \"uptime\": <uptime in seconds>,",
+        "        \"reload\": <time since reload in seconds>,",
+        "        \"ha-servers\": {",
+        "            \"local\": {",
+        "                \"role\": <role of this server as in the configuration file>,",
+        "                \"scopes\": <list of scope names served by this server>,",
+        "                \"state\": <HA state name of the server receiving the command>,",
+        "            },",
+        "            \"remote\": {",
+        "                \"age\": <the age of the remote status in seconds>,",
+        "                \"in-touch\": <indicates if this server communicated with remote>,",
+        "                \"last-scopes\": <list of scopes served by partner>,",
+        "                \"last-state\": <HA state name of the partner>,",
+        "                \"role\": <partner role>",
+        "            }",
+        "        }",
+        "    }",
+        "}"
+    ],
+
+    "support": [
+        "kea-dhcp4",
+        "kea-dhcp6",
+        "kea-dhcp-ddns",
+        "kea-ctrl-agent"
+    ]
+}
diff --git a/src/bin/agent/ca_controller.cc b/src/bin/agent/ca_controller.cc
index 38d5733e97..134bde5659 100644
--- a/src/bin/agent/ca_controller.cc
+++ b/src/bin/agent/ca_controller.cc
@@ -72,6 +72,9 @@ CtrlAgentController::registerCommands() {
     CtrlAgentCommandMgr::instance().registerCommand(SHUT_DOWN_COMMAND,
         boost::bind(&DControllerBase::shutdownHandler, this, _1, _2));
 
+    CtrlAgentCommandMgr::instance().registerCommand(STATUS_GET_COMMAND,
+        boost::bind(&DControllerBase::statusGetHandler, this, _1, _2));
+
     CtrlAgentCommandMgr::instance().registerCommand(VERSION_GET_COMMAND,
         boost::bind(&DControllerBase::versionGetHandler, this, _1, _2));
 }
@@ -85,6 +88,7 @@ CtrlAgentController::deregisterCommands() {
     CtrlAgentCommandMgr::instance().deregisterCommand(CONFIG_TEST_COMMAND);
     CtrlAgentCommandMgr::instance().deregisterCommand(CONFIG_WRITE_COMMAND);
     CtrlAgentCommandMgr::instance().deregisterCommand(SHUT_DOWN_COMMAND);
+    CtrlAgentCommandMgr::instance().deregisterCommand(STATUS_GET_COMMAND);
     CtrlAgentCommandMgr::instance().deregisterCommand(VERSION_GET_COMMAND);
 }
 
diff --git a/src/bin/agent/tests/ca_controller_unittests.cc b/src/bin/agent/tests/ca_controller_unittests.cc
index b7223eff5e..dcda359c97 100644
--- a/src/bin/agent/tests/ca_controller_unittests.cc
+++ b/src/bin/agent/tests/ca_controller_unittests.cc
@@ -13,6 +13,7 @@
 #include <process/testutils/d_test_stubs.h>
 #include <boost/pointer_cast.hpp>
 #include <sstream>
+#include <unistd.h>
 
 using namespace std;
 using namespace isc::agent;
@@ -454,6 +455,7 @@ TEST_F(CtrlAgentControllerTest, registeredCommands) {
     checkCommandRegistered("config-write");
     checkCommandRegistered("list-commands");
     checkCommandRegistered("shutdown");
+    checkCommandRegistered("status-get");
     checkCommandRegistered("version-get");
 
     ctrl->deregisterCommands();
@@ -657,4 +659,42 @@ TEST_F(CtrlAgentControllerTest, configReloadFileValid) {
     ctrl->deregisterCommands();
 }
 
+// Tests that status-get returns expected info (pid, uptime and reload).
+TEST_F(CtrlAgentControllerTest, statusGet) {
+    // Start the server.
+    time_duration elapsed_time;
+    runWithConfig(valid_agent_config, 500, elapsed_time);
+
+    const DControllerBasePtr& ctrl = getController();
+    ConstElementPtr response;
+    ASSERT_NO_THROW(response = ctrl->statusGetHandler("status-get", ConstElementPtr()));
+    ASSERT_TRUE(response);
+    ASSERT_EQ(Element::map, response->getType());
+    EXPECT_EQ(2, response->size());
+    ConstElementPtr result = response->get("result");
+    ASSERT_TRUE(result);
+    ASSERT_EQ(Element::integer, result->getType());
+    EXPECT_EQ(0, result->intValue());
+    ConstElementPtr arguments = response->get("arguments");
+    ASSERT_EQ(Element::map, arguments->getType());
+
+    // The returned pid should be the pid of our process.
+    auto found_pid = arguments->get("pid");
+    ASSERT_TRUE(found_pid);
+    EXPECT_EQ(static_cast<int64_t>(getpid()), found_pid->intValue());
+
+    // It is hard to check the actual uptime (and reload) as it is based
+    // on current time. Let's just make sure it is within a reasonable
+    // range.
+    auto found_uptime = arguments->get("uptime");
+    ASSERT_TRUE(found_uptime);
+    EXPECT_LE(found_uptime->intValue(), 5);
+    EXPECT_GE(found_uptime->intValue(), 0);
+
+    auto found_reload = arguments->get("reload");
+    ASSERT_TRUE(found_reload);
+    EXPECT_LE(found_reload->intValue(), 5);
+    EXPECT_GE(found_reload->intValue(), 0);
+}
+
 }
diff --git a/src/bin/d2/d2_controller.cc b/src/bin/d2/d2_controller.cc
index aceca355d3..30bfbf39b2 100644
--- a/src/bin/d2/d2_controller.cc
+++ b/src/bin/d2/d2_controller.cc
@@ -73,6 +73,9 @@ D2Controller::registerCommands() {
     CommandMgr::instance().registerCommand(SHUT_DOWN_COMMAND,
         boost::bind(&D2Controller::shutdownHandler, this, _1, _2));
 
+    CommandMgr::instance().registerCommand(STATUS_GET_COMMAND,
+        boost::bind(&DControllerBase::statusGetHandler, this, _1, _2));
+
     CommandMgr::instance().registerCommand(VERSION_GET_COMMAND,
         boost::bind(&D2Controller::versionGetHandler, this, _1, _2));
 }
@@ -91,6 +94,7 @@ D2Controller::deregisterCommands() {
         CommandMgr::instance().deregisterCommand(CONFIG_TEST_COMMAND);
         CommandMgr::instance().deregisterCommand(CONFIG_WRITE_COMMAND);
         CommandMgr::instance().deregisterCommand(SHUT_DOWN_COMMAND);
+        CommandMgr::instance().deregisterCommand(STATUS_GET_COMMAND);
         CommandMgr::instance().deregisterCommand(VERSION_GET_COMMAND);
 
     } catch (...) {
diff --git a/src/bin/d2/tests/d2_command_unittest.cc b/src/bin/d2/tests/d2_command_unittest.cc
index 29d4b17457..c6690d75e2 100644
--- a/src/bin/d2/tests/d2_command_unittest.cc
+++ b/src/bin/d2/tests/d2_command_unittest.cc
@@ -23,6 +23,7 @@
 #include <iostream>
 #include <sstream>
 #include <thread>
+#include <unistd.h>
 
 using namespace std;
 using namespace isc;
@@ -537,6 +538,7 @@ TEST_F(CtrlChannelD2Test, commandsRegistration) {
     EXPECT_TRUE(command_list.find("\"config-test\"") != string::npos);
     EXPECT_TRUE(command_list.find("\"config-write\"") != string::npos);
     EXPECT_TRUE(command_list.find("\"shutdown\"") != string::npos);
+    EXPECT_TRUE(command_list.find("\"status-get\"") != string::npos);
     EXPECT_TRUE(command_list.find("\"version-get\"") != string::npos);
 
     // Ok, and now delete the server. It should deregister its commands.
@@ -612,6 +614,45 @@ TEST_F(CtrlChannelD2Test, listCommands) {
     checkListCommands(rsp, "version-get");
 }
 
+// This test verifies that the D2 server handles status-get commands
+TEST_F(CtrlChannelD2Test, statusGet) {
+    EXPECT_NO_THROW(createUnixChannelServer());
+
+    std::string response_txt;
+
+    // Send the version-get command
+    sendUnixCommand("{ \"command\": \"status-get\" }", response_txt);
+    ConstElementPtr response;
+    ASSERT_NO_THROW(response = Element::fromJSON(response_txt));
+    ASSERT_TRUE(response);
+    ASSERT_EQ(Element::map, response->getType());
+    EXPECT_EQ(2, response->size());
+    ConstElementPtr result = response->get("result");
+    ASSERT_TRUE(result);
+    ASSERT_EQ(Element::integer, result->getType());
+    EXPECT_EQ(0, result->intValue());
+    ConstElementPtr arguments = response->get("arguments");
+    ASSERT_EQ(Element::map, arguments->getType());
+
+    // The returned pid should be the pid of our process.
+    auto found_pid = arguments->get("pid");
+    ASSERT_TRUE(found_pid);
+    EXPECT_EQ(static_cast<int64_t>(getpid()), found_pid->intValue());
+
+    // It is hard to check the actual reload time as it is based
+    // on current time. Let's just make sure it is within a reasonable
+    // range.
+    auto found_reload = arguments->get("reload");
+    ASSERT_TRUE(found_reload);
+    EXPECT_LE(found_reload->intValue(), 5);
+    EXPECT_GE(found_reload->intValue(), 0);
+
+    /// @todo uptime is not available in this test, because the launch()
+    /// function is not called. This is not critical to test here,
+    /// because the same logic is tested for CA and in that case the
+    /// uptime is tested.
+}
+
 // Tests if the server returns its configuration using config-get.
 // Note there are separate tests that verify if toElement() called by the
 // config-get handler are actually converting the configuration correctly.
diff --git a/src/bin/dhcp4/ctrl_dhcp4_srv.cc b/src/bin/dhcp4/ctrl_dhcp4_srv.cc
index 5618e231ff..f40a38652e 100644
--- a/src/bin/dhcp4/ctrl_dhcp4_srv.cc
+++ b/src/bin/dhcp4/ctrl_dhcp4_srv.cc
@@ -79,6 +79,9 @@ ControlledDhcpv4Srv* ControlledDhcpv4Srv::server_ = NULL;
 
 void
 ControlledDhcpv4Srv::init(const std::string& file_name) {
+    // Keep the call timestamp.
+    start_ = boost::posix_time::second_clock::universal_time();
+
     // Configure the server using JSON file.
     ConstElementPtr result = loadConfigFile(file_name);
     int rcode;
@@ -574,6 +577,30 @@ ControlledDhcpv4Srv::commandConfigBackendPullHandler(const std::string&,
                          "On demand configuration update successful."));
 }
 
+ConstElementPtr
+ControlledDhcpv4Srv::commandStatusGetHandler(const string&,
+                                             ConstElementPtr /*args*/) {
+    ElementPtr status = Element::createMap();
+    status->set("pid", Element::create(static_cast<int>(getpid())));
+
+    auto now = boost::posix_time::second_clock::universal_time();
+    // Sanity check: start_ is always initialized.
+    if (!start_.is_not_a_date_time()) {
+        auto uptime = now - start_;
+        status->set("uptime", Element::create(uptime.total_seconds()));
+    }
+
+    auto last_commit = CfgMgr::instance().getCurrentCfg()->getLastCommitTime();
+    if (!last_commit.is_not_a_date_time()) {
+        auto reload = now - last_commit;
+        status->set("reload", Element::create(reload.total_seconds()));
+    }
+
+    // todo: number of service threads.
+
+    return (createAnswer(0, status));
+}
+
 ConstElementPtr
 ControlledDhcpv4Srv::processCommand(const string& command,
                                     ConstElementPtr args) {
@@ -634,6 +661,8 @@ ControlledDhcpv4Srv::processCommand(const string& command,
         } else if (command == "config-backend-pull") {
             return (srv->commandConfigBackendPullHandler(command, args));
 
+        } else if (command == "status-get") {
+            return (srv->commandStatusGetHandler(command, args));
         }
         ConstElementPtr answer = isc::config::createAnswer(1,
                                  "Unrecognized command:" + command);
@@ -877,6 +906,9 @@ ControlledDhcpv4Srv::ControlledDhcpv4Srv(uint16_t server_port /*= DHCP4_SERVER_P
     CommandMgr::instance().registerCommand("shutdown",
         boost::bind(&ControlledDhcpv4Srv::commandShutdownHandler, this, _1, _2));
 
+    CommandMgr::instance().registerCommand("status-get",
+        boost::bind(&ControlledDhcpv4Srv::commandStatusGetHandler, this, _1, _2));
+
     CommandMgr::instance().registerCommand("version-get",
         boost::bind(&ControlledDhcpv4Srv::commandVersionGetHandler, this, _1, _2));
 
@@ -954,6 +986,7 @@ ControlledDhcpv4Srv::~ControlledDhcpv4Srv() {
         CommandMgr::instance().deregisterCommand("statistic-sample-age-set-all");
         CommandMgr::instance().deregisterCommand("statistic-sample-count-set");
         CommandMgr::instance().deregisterCommand("statistic-sample-count-set-all");
+        CommandMgr::instance().deregisterCommand("status-get");
         CommandMgr::instance().deregisterCommand("version-get");
 
     } catch (...) {
diff --git a/src/bin/dhcp4/ctrl_dhcp4_srv.h b/src/bin/dhcp4/ctrl_dhcp4_srv.h
index d67501da50..49ffdff551 100644
--- a/src/bin/dhcp4/ctrl_dhcp4_srv.h
+++ b/src/bin/dhcp4/ctrl_dhcp4_srv.h
@@ -317,6 +317,18 @@ private:
     commandConfigBackendPullHandler(const std::string& command,
                                     isc::data::ConstElementPtr args);
 
+    /// @brief handler for processing 'status-get' command
+    ///
+    /// This handler processes status-get command, which retrieves
+    /// the server process information i.e. the pid and returns it in response.
+    ///
+    /// @param command (ignored)
+    /// @param args (ignored)
+    /// @return process information wrapped in a response
+    isc::data::ConstElementPtr
+    commandStatusGetHandler(const std::string& command,
+                            isc::data::ConstElementPtr args);
+
     /// @brief Reclaims expired IPv4 leases and reschedules timer.
     ///
     /// This is a wrapper method for @c AllocEngine::reclaimExpiredLeases4.
diff --git a/src/bin/dhcp4/tests/ctrl_dhcp4_srv_unittest.cc b/src/bin/dhcp4/tests/ctrl_dhcp4_srv_unittest.cc
index 029055ac3d..8930bc2aec 100644
--- a/src/bin/dhcp4/tests/ctrl_dhcp4_srv_unittest.cc
+++ b/src/bin/dhcp4/tests/ctrl_dhcp4_srv_unittest.cc
@@ -497,6 +497,7 @@ TEST_F(CtrlChannelDhcpv4SrvTest, commandsRegistration) {
     EXPECT_TRUE(command_list.find("\"statistic-sample-age-set-all\"") != string::npos);
     EXPECT_TRUE(command_list.find("\"statistic-sample-count-set\"") != string::npos);
     EXPECT_TRUE(command_list.find("\"statistic-sample-count-set-all\"") != string::npos);
+    EXPECT_TRUE(command_list.find("\"status-get\"") != string::npos);
     EXPECT_TRUE(command_list.find("\"version-get\"") != string::npos);
 
     // Ok, and now delete the server. It should deregister its commands.
@@ -1026,6 +1027,48 @@ TEST_F(CtrlChannelDhcpv4SrvTest, serverTagGet) {
     expected = "{ \"arguments\": { \"server-tag\": \"foobar\" }, \"result\": 0 }";
 }
 
+// This test verifies that the DHCP server handles status-get commands
+TEST_F(CtrlChannelDhcpv4SrvTest, statusGet) {
+    createUnixChannelServer();
+
+    // start_ is initialized by init.
+    ASSERT_THROW(server_->init("/no/such/file"), BadValue);
+
+    std::string response_txt;
+
+    // Send the version-get command
+    sendUnixCommand("{ \"command\": \"status-get\" }", response_txt);
+    ConstElementPtr response;
+    ASSERT_NO_THROW(response = Element::fromJSON(response_txt));
+    ASSERT_TRUE(response);
+    ASSERT_EQ(Element::map, response->getType());
+    EXPECT_EQ(2, response->size());
+    ConstElementPtr result = response->get("result");
+    ASSERT_TRUE(result);
+    ASSERT_EQ(Element::integer, result->getType());
+    EXPECT_EQ(0, result->intValue());
+    ConstElementPtr arguments = response->get("arguments");
+    ASSERT_EQ(Element::map, arguments->getType());
+
+    // The returned pid should be the pid of our process.
+    auto found_pid = arguments->get("pid");
+    ASSERT_TRUE(found_pid);
+    EXPECT_EQ(static_cast<int64_t>(getpid()), found_pid->intValue());
+
+    // It is hard to check the actual uptime (and reload) as it is based
+    // on current time. Let's just make sure it is within a reasonable
+    // range.
+    auto found_uptime = arguments->get("uptime");
+    ASSERT_TRUE(found_uptime);
+    EXPECT_LE(found_uptime->intValue(), 5);
+    EXPECT_GE(found_uptime->intValue(), 0);
+
+    auto found_reload = arguments->get("reload");
+    ASSERT_TRUE(found_reload);
+    EXPECT_LE(found_reload->intValue(), 5);
+    EXPECT_GE(found_reload->intValue(), 0);
+}
+
 // This test verifies that the DHCP server handles config-backend-pull command
 TEST_F(CtrlChannelDhcpv4SrvTest, configBackendPull) {
     createUnixChannelServer();
diff --git a/src/bin/dhcp6/ctrl_dhcp6_srv.cc b/src/bin/dhcp6/ctrl_dhcp6_srv.cc
index 5146443061..7445f8a41e 100644
--- a/src/bin/dhcp6/ctrl_dhcp6_srv.cc
+++ b/src/bin/dhcp6/ctrl_dhcp6_srv.cc
@@ -163,6 +163,9 @@ ControlledDhcpv6Srv::loadConfigFile(const std::string& file_name) {
 
 void
 ControlledDhcpv6Srv::init(const std::string& file_name) {
+    // Keep the call timestamp.
+    start_ = boost::posix_time::second_clock::universal_time();
+
     // Configure the server using JSON file.
     ConstElementPtr result = loadConfigFile(file_name);
     int rcode;
@@ -574,6 +577,30 @@ ControlledDhcpv6Srv::commandConfigBackendPullHandler(const std::string&,
                          "On demand configuration update successful."));
 }
 
+ConstElementPtr
+ControlledDhcpv6Srv::commandStatusGetHandler(const string&,
+                                             ConstElementPtr /*args*/) {
+    ElementPtr status = Element::createMap();
+    status->set("pid", Element::create(static_cast<int>(getpid())));
+
+    auto now = boost::posix_time::second_clock::universal_time();
+    // Sanity check: start_ is always initialized.
+    if (!start_.is_not_a_date_time()) {
+        auto uptime = now - start_;
+        status->set("uptime", Element::create(uptime.total_seconds()));
+    }
+
+    auto last_commit = CfgMgr::instance().getCurrentCfg()->getLastCommitTime();
+    if (!last_commit.is_not_a_date_time()) {
+        auto reload = now - last_commit;
+        status->set("reload", Element::create(reload.total_seconds()));
+    }
+
+    // todo: number of service threads.
+
+    return (createAnswer(0, status));
+}
+
 isc::data::ConstElementPtr
 ControlledDhcpv6Srv::processCommand(const std::string& command,
                                     isc::data::ConstElementPtr args) {
@@ -634,6 +661,8 @@ ControlledDhcpv6Srv::processCommand(const std::string& command,
         } else if (command == "config-backend-pull") {
             return (srv->commandConfigBackendPullHandler(command, args));
 
+        } else if (command == "status-get") {
+            return (srv->commandStatusGetHandler(command, args));
         }
 
         return (isc::config::createAnswer(1, "Unrecognized command:"
@@ -896,6 +925,9 @@ ControlledDhcpv6Srv::ControlledDhcpv6Srv(uint16_t server_port,
     CommandMgr::instance().registerCommand("shutdown",
         boost::bind(&ControlledDhcpv6Srv::commandShutdownHandler, this, _1, _2));
 
+    CommandMgr::instance().registerCommand("status-get",
+        boost::bind(&ControlledDhcpv6Srv::commandStatusGetHandler, this, _1, _2));
+
     CommandMgr::instance().registerCommand("version-get",
         boost::bind(&ControlledDhcpv6Srv::commandVersionGetHandler, this, _1, _2));
 
@@ -973,6 +1005,7 @@ ControlledDhcpv6Srv::~ControlledDhcpv6Srv() {
         CommandMgr::instance().deregisterCommand("statistic-sample-age-set-all");
         CommandMgr::instance().deregisterCommand("statistic-sample-count-set");
         CommandMgr::instance().deregisterCommand("statistic-sample-count-set-all");
+        CommandMgr::instance().deregisterCommand("status-get");
         CommandMgr::instance().deregisterCommand("version-get");
 
     } catch (...) {
diff --git a/src/bin/dhcp6/ctrl_dhcp6_srv.h b/src/bin/dhcp6/ctrl_dhcp6_srv.h
index fbe7252337..12983d1875 100644
--- a/src/bin/dhcp6/ctrl_dhcp6_srv.h
+++ b/src/bin/dhcp6/ctrl_dhcp6_srv.h
@@ -316,6 +316,18 @@ private:
     commandConfigBackendPullHandler(const std::string& command,
                                     isc::data::ConstElementPtr args);
 
+    /// @brief handler for processing 'status-get' command
+    ///
+    /// This handler processes status-get command, which retrieves
+    /// the server process information i.e. the pid and returns it in response.
+    ///
+    /// @param command (ignored)
+    /// @param args (ignored)
+    /// @return process information wrapped in a response
+    isc::data::ConstElementPtr
+    commandStatusGetHandler(const std::string& command,
+                            isc::data::ConstElementPtr args);
+
     /// @brief Reclaims expired IPv6 leases and reschedules timer.
     ///
     /// This is a wrapper method for @c AllocEngine::reclaimExpiredLeases6.
diff --git a/src/bin/dhcp6/tests/ctrl_dhcp6_srv_unittest.cc b/src/bin/dhcp6/tests/ctrl_dhcp6_srv_unittest.cc
index 44890b1b2c..e81065716f 100644
--- a/src/bin/dhcp6/tests/ctrl_dhcp6_srv_unittest.cc
+++ b/src/bin/dhcp6/tests/ctrl_dhcp6_srv_unittest.cc
@@ -36,6 +36,7 @@
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 #include <cstdlib>
+#include <unistd.h>
 
 #include <thread>
 
@@ -516,6 +517,7 @@ TEST_F(CtrlDhcpv6SrvTest, commandsRegistration) {
     EXPECT_TRUE(command_list.find("\"statistic-sample-age-set-all\"") != string::npos);
     EXPECT_TRUE(command_list.find("\"statistic-sample-count-set\"") != string::npos);
     EXPECT_TRUE(command_list.find("\"statistic-sample-count-set-all\"") != string::npos);
+    EXPECT_TRUE(command_list.find("\"status-get\"") != string::npos);
     EXPECT_TRUE(command_list.find("\"version-get\"") != string::npos);
 
     // Ok, and now delete the server. It should deregister its commands.
@@ -918,6 +920,48 @@ TEST_F(CtrlChannelDhcpv6SrvTest, getVersion) {
     EXPECT_TRUE(response.find("GTEST_VERSION") != string::npos);
 }
 
+// This test verifies that the DHCP server handles status-get commands
+TEST_F(CtrlChannelDhcpv6SrvTest, statusGet) {
+    createUnixChannelServer();
+
+    // start_ is initialized by init.
+    ASSERT_THROW(server_->init("/no/such/file"), BadValue);
+
+    std::string response_txt;
+
+    // Send the version-get command
+    sendUnixCommand("{ \"command\": \"status-get\" }", response_txt);
+    ConstElementPtr response;
+    ASSERT_NO_THROW(response = Element::fromJSON(response_txt));
+    ASSERT_TRUE(response);
+    ASSERT_EQ(Element::map, response->getType());
+    EXPECT_EQ(2, response->size());
+    ConstElementPtr result = response->get("result");
+    ASSERT_TRUE(result);
+    ASSERT_EQ(Element::integer, result->getType());
+    EXPECT_EQ(0, result->intValue());
+    ConstElementPtr arguments = response->get("arguments");
+    ASSERT_EQ(Element::map, arguments->getType());
+
+    // The returned pid should be the pid of our process.
+    auto found_pid = arguments->get("pid");
+    ASSERT_TRUE(found_pid);
+    EXPECT_EQ(static_cast<int64_t>(getpid()), found_pid->intValue());
+
+    // It is hard to check the actual uptime (and reload) as it is based
+    // on current time. Let's just make sure it is within a reasonable
+    // range.
+    auto found_uptime = arguments->get("uptime");
+    ASSERT_TRUE(found_uptime);
+    EXPECT_LE(found_uptime->intValue(), 5);
+    EXPECT_GE(found_uptime->intValue(), 0);
+
+    auto found_reload = arguments->get("reload");
+    ASSERT_TRUE(found_reload);
+    EXPECT_LE(found_reload->intValue(), 5);
+    EXPECT_GE(found_reload->intValue(), 0);
+}
+
 // This test verifies that the DHCP server handles server-tag-get command
 TEST_F(CtrlChannelDhcpv6SrvTest, serverTagGet) {
     createUnixChannelServer();
diff --git a/src/bin/shell/tests/shell_process_tests.sh.in b/src/bin/shell/tests/shell_process_tests.sh.in
index 3a9545c489..dba762060f 100644
--- a/src/bin/shell/tests/shell_process_tests.sh.in
+++ b/src/bin/shell/tests/shell_process_tests.sh.in
@@ -178,7 +178,7 @@ version_test() {
 
 version_test "shell.version"
 shell_command_test "shell.list-commands" "list-commands" \
-    "[ { \"arguments\": [ \"build-report\", \"config-get\", \"config-reload\", \"config-set\", \"config-test\", \"config-write\", \"list-commands\", \"shutdown\", \"version-get\" ], \"result\": 0 } ]" ""
+    "[ { \"arguments\": [ \"build-report\", \"config-get\", \"config-reload\", \"config-set\", \"config-test\", \"config-write\", \"list-commands\", \"shutdown\", \"status-get\", \"version-get\" ], \"result\": 0 } ]" ""
 shell_command_test "shell.bogus" "give-me-a-beer" \
 "[ { \"result\": 2, \"text\": \"'give-me-a-beer' command not supported. You did not include \\\"service\\\" parameter in the command, which indicates that Kea Control Agent should process this command rather than forward it to one or more Kea servers. If you aimed to send this command to one of the Kea servers you should include the \\\"service\\\" parameter in your request, e.g. \\\"service\\\": [ \\\"dhcp4\\\" ] to forward the command to the DHCPv4 server, or \\\"service\\\": [ \\\"dhcp4\\\", \\\"dhcp6\\\", \\\"d2\\\" ] to forward it to DHCPv4, DHCPv6 and D2 servers etc.\" } ]" ""
 shell_command_test "shell.empty-config-test" "config-test" \
diff --git a/src/hooks/dhcp/high_availability/communication_state.cc b/src/hooks/dhcp/high_availability/communication_state.cc
index 6ffd48f827..260abc8632 100644
--- a/src/hooks/dhcp/high_availability/communication_state.cc
+++ b/src/hooks/dhcp/high_availability/communication_state.cc
@@ -7,6 +7,7 @@
 #include <config.h>
 
 #include <communication_state.h>
+#include <exceptions/exceptions.h>
 #include <ha_service_states.h>
 #include <exceptions/exceptions.h>
 #include <dhcp/dhcp4.h>
@@ -22,6 +23,7 @@
 #include <utility>
 
 using namespace isc::asiolink;
+using namespace isc::data;
 using namespace isc::dhcp;
 using namespace isc::http;
 using namespace boost::posix_time;
@@ -46,8 +48,9 @@ CommunicationState::CommunicationState(const IOServicePtr& io_service,
                                        const HAConfigPtr& config)
     : io_service_(io_service), config_(config), timer_(), interval_(0),
       poke_time_(boost::posix_time::microsec_clock::universal_time()),
-      heartbeat_impl_(0), partner_state_(-1), clock_skew_(0, 0, 0, 0),
-      last_clock_skew_warn_(), my_time_at_skew_(), partner_time_at_skew_() {
+      heartbeat_impl_(0), partner_state_(-1), partner_scopes_(),
+      clock_skew_(0, 0, 0, 0), last_clock_skew_warn_(),
+      my_time_at_skew_(), partner_time_at_skew_() {
 }
 
 CommunicationState::~CommunicationState() {
@@ -78,6 +81,28 @@ CommunicationState::setPartnerState(const std::string& state) {
     }
 }
 
+void
+CommunicationState::setPartnerScopes(ConstElementPtr new_scopes) {
+    if (!new_scopes || (new_scopes->getType() != Element::list)) {
+        isc_throw(BadValue, "unable to record partner's HA scopes because"
+                  " the received value is not a valid JSON list");
+    }
+
+    std::set<std::string> partner_scopes;
+    for (auto i = 0; i < new_scopes->size(); ++i) {
+        auto scope = new_scopes->get(i);
+        if (scope->getType() != Element::string) {
+            isc_throw(BadValue, "unable to record partner's HA scopes because"
+                      " the received scope value is not a valid JSON string");
+        }
+        auto scope_str = scope->stringValue();
+        if (!scope_str.empty()) {
+            partner_scopes.insert(scope_str);
+        }
+    }
+    partner_scopes_ = partner_scopes;
+}
+
 void
 CommunicationState::startHeartbeat(const long interval,
                                    const boost::function<void()>& heartbeat_impl) {
diff --git a/src/hooks/dhcp/high_availability/communication_state.h b/src/hooks/dhcp/high_availability/communication_state.h
index 1bc80e889b..1ced58daec 100644
--- a/src/hooks/dhcp/high_availability/communication_state.h
+++ b/src/hooks/dhcp/high_availability/communication_state.h
@@ -11,6 +11,7 @@
 #include <ha_service_states.h>
 #include <asiolink/interval_timer.h>
 #include <asiolink/io_service.h>
+#include <cc/data.h>
 #include <dhcp/pkt.h>
 #include <boost/date_time/posix_time/posix_time.hpp>
 #include <boost/function.hpp>
@@ -100,6 +101,12 @@ public:
     /// @throw BadValue if unsupported state value was provided.
     void setPartnerState(const std::string& state);
 
+    std::set<std::string> getPartnerScopes() const {
+        return (partner_scopes_);
+    }
+
+    void setPartnerScopes(data::ConstElementPtr new_scopes);
+
     /// @brief Starts recurring heartbeat (public interface).
     ///
     /// @param interval heartbeat interval in milliseconds.
@@ -313,6 +320,9 @@ protected:
     /// Negative value means that the partner's state is unknown.
     int partner_state_;
 
+    /// @brief Last known set of scopes served by the partner server.
+    std::set<std::string> partner_scopes_;
+
     /// @brief Clock skew between the active servers.
     boost::posix_time::time_duration clock_skew_;
 
diff --git a/src/hooks/dhcp/high_availability/ha_impl.cc b/src/hooks/dhcp/high_availability/ha_impl.cc
index 46fadf68b6..78fcd62d25 100644
--- a/src/hooks/dhcp/high_availability/ha_impl.cc
+++ b/src/hooks/dhcp/high_availability/ha_impl.cc
@@ -1,4 +1,4 @@
-// Copyright (C) 2018 Internet Systems Consortium, Inc. ("ISC")
+// Copyright (C) 2018-2019 Internet Systems Consortium, Inc. ("ISC")
 //
 // This Source Code Form is subject to the terms of the Mozilla Public
 // License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -262,6 +262,23 @@ HAImpl::commandProcessed(hooks::CalloutHandle& callout_handle) {
     callout_handle.getArgument("name", command_name);
     if (command_name == "dhcp-enable") {
         service_->adjustNetworkState();
+    } else if (command_name == "status-get") {
+        // Get the response.
+        ConstElementPtr response;
+        callout_handle.getArgument("response", response);
+        if (!response || (response->getType() != Element::map)) {
+            return;
+        }
+        // Get the arguments item from the response.
+        ConstElementPtr resp_args = response->get("arguments");
+        if (!resp_args || (resp_args->getType() != Element::map)) {
+            return;
+        }
+        // Add the ha servers info to arguments.
+        ElementPtr mutable_resp_args =
+            boost::const_pointer_cast<Element>(resp_args);
+        ConstElementPtr ha_servers = service_->processStatusGet();
+        mutable_resp_args->set("ha-servers", ha_servers);
     }
 }
 
@@ -396,6 +413,5 @@ HAImpl::continueHandler(hooks::CalloutHandle& callout_handle) {
     callout_handle.setArgument("response", response);
 }
 
-
 } // end of namespace isc::ha
 } // end of namespace isc
diff --git a/src/hooks/dhcp/high_availability/ha_impl.h b/src/hooks/dhcp/high_availability/ha_impl.h
index a27892ba57..ebecf68edf 100644
--- a/src/hooks/dhcp/high_availability/ha_impl.h
+++ b/src/hooks/dhcp/high_availability/ha_impl.h
@@ -1,4 +1,4 @@
-// Copyright (C) 2018 Internet Systems Consortium, Inc. ("ISC")
+// Copyright (C) 2018-2019 Internet Systems Consortium, Inc. ("ISC")
 //
 // This Source Code Form is subject to the terms of the Mozilla Public
 // License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -118,6 +118,8 @@ public:
     /// service is enabled in a state for which this is not allowed, e.g.
     /// waiting, syncing etc. We don't want to rely on the HA partner to do
     /// a correct thing in that respect.
+    /// It too adds the HA servers information to "status-get" command
+    /// responses by calling @c HAService::commandProcessed.
     ///
     /// @param callout_handle Callout handle provided to the callout.
     void commandProcessed(hooks::CalloutHandle& callout_handle);
diff --git a/src/hooks/dhcp/high_availability/ha_service.cc b/src/hooks/dhcp/high_availability/ha_service.cc
index 77106bef18..5fd203c6c9 100644
--- a/src/hooks/dhcp/high_availability/ha_service.cc
+++ b/src/hooks/dhcp/high_availability/ha_service.cc
@@ -952,6 +952,75 @@ HAService::logFailedLeaseUpdates(const PktPtr& query,
     log_proc(query, args, "failed-leases", HA_LEASE_UPDATE_CREATE_UPDATE_FAILED_ON_PEER);
 }
 
+ConstElementPtr
+HAService::processStatusGet() const {
+    ElementPtr ha_servers = Element::createMap();
+
+    // Local part
+    ElementPtr local = Element::createMap();
+    HAConfig::PeerConfig::Role role;
+    role = config_->getThisServerConfig()->getRole();
+    std::string role_txt = HAConfig::PeerConfig::roleToString(role);
+    local->set("role", Element::create(role_txt));
+    int state = getCurrState();
+    try {
+        local->set("state", Element::create(stateToString(state)));
+
+    } catch (...) {
+        // Empty string on error.
+        local->set("state", Element::create(std::string()));
+    }
+    std::set<std::string> scopes = query_filter_.getServedScopes();
+    ElementPtr list = Element::createList();
+    for (std::string scope : scopes) {
+        list->add(Element::create(scope));
+    }
+    local->set("scopes", list);
+    ha_servers->set("local", local);
+
+    // Remote part
+    ElementPtr remote = Element::createMap();
+
+    // Add the in-touch boolean flag to indicate whether there was any
+    // communication between the HA peers. Based on that, the user
+    // may determine if the status returned for the peer is based on
+    // the heartbeat or is to be determined.
+    auto in_touch = (communication_state_->getPartnerState() > 0);
+    remote->set("in-touch", Element::create(in_touch));
+
+    auto age = in_touch ?
+        static_cast<long long int>(communication_state_->getDurationInMillisecs() / 1000) : 0;
+    remote->set("age", Element::create(age));
+
+    try {
+        role = config_->getFailoverPeerConfig()->getRole();
+        std::string role_txt = HAConfig::PeerConfig::roleToString(role);
+        remote->set("role", Element::create(role_txt));
+
+    } catch (...) {
+        remote->set("role", Element::create(std::string()));
+    }
+
+    try {
+        state = getPartnerState();
+        remote->set("last-state", Element::create(stateToString(state)));
+
+    } catch (...) {
+        remote->set("last-state", Element::create(std::string()));
+    }
+
+    // Remote server's scopes.
+    scopes = communication_state_->getPartnerScopes();
+    list = Element::createList();
+    for (auto scope : scopes) {
+        list->add(Element::create(scope));
+    }
+    remote->set("last-scopes", list);
+    ha_servers->set("remote", remote);
+
+    return (ha_servers);
+}
+
 ConstElementPtr
 HAService::processHeartbeat() {
     ElementPtr arguments = Element::createMap();
@@ -961,6 +1030,13 @@ HAService::processHeartbeat() {
     std::string date_time = HttpDateTime().rfc1123Format();
     arguments->set("date-time", Element::create(date_time));
 
+    auto scopes = query_filter_.getServedScopes();
+    ElementPtr scopes_list = Element::createList();
+    for (auto scope : scopes) {
+        scopes_list->add(Element::create(scope));
+    }
+    arguments->set("scopes", scopes_list);
+
     return (createAnswer(CONTROL_RESULT_SUCCESS, "HA peer status returned.",
                          arguments));
 }
@@ -1031,6 +1107,19 @@ HAService::asyncSendHeartbeat() {
                     // Note the time returned by the partner to calculate the clock skew.
                     communication_state_->setPartnerTime(date_time->stringValue());
 
+                    // Remember the scopes served by the partner.
+                    try {
+                        auto scopes = args->get("scopes");
+                        communication_state_->setPartnerScopes(scopes);
+
+                    } catch (...) {
+                        // We don't want to fail if the scopes are missing because
+                        // this would be incompatible with old HA hook library
+                        // versions. We may make it mandatory one day, but during
+                        // upgrades of existing HA setup it would be a real issue
+                        // if we failed here.
+                    }
+
                 } catch (const std::exception& ex) {
                     LOG_WARN(ha_logger, HA_HEARTBEAT_FAILED)
                         .arg(partner_config->getLogLabel())
diff --git a/src/hooks/dhcp/high_availability/ha_service.h b/src/hooks/dhcp/high_availability/ha_service.h
index 14486e1a80..6bd4ab8613 100644
--- a/src/hooks/dhcp/high_availability/ha_service.h
+++ b/src/hooks/dhcp/high_availability/ha_service.h
@@ -246,6 +246,12 @@ public:
     /// queries.
     void waitingStateHandler();
 
+    /// @brief Returns last known state of the partner.
+    /// @ref CommunicationState::getPartnerState.
+    int getPartnerState() const {
+        return (communication_state_->getPartnerState());
+    }
+
 protected:
 
     /// @brief Transitions to a desired state and logs it.
@@ -485,12 +491,13 @@ public:
     /// a restart.
     ///
     /// The ha-heartbeat command takes no arguments. The response contains
-    /// a server state and timestamp in the following format:
+    /// a server state, served scopes and timestamp in the following format:
     ///
     /// @code
     /// {
     ///     "arguments": {
     ///         "date-time": "Thu, 01 Feb 2018 21:18:26 GMT",
+    ///         "scopes": [ "server1" ],
     ///         "state": "waiting"
     ///     },
     ///     "result": 0,
@@ -501,6 +508,14 @@ public:
     /// @return Pointer to the response to the heartbeat.
     data::ConstElementPtr processHeartbeat();
 
+    /// @brief Processes status-get command and returns a response.
+    ///
+    ///
+    ///
+    /// @c HAImpl::commandProcessed calls this to add information about the
+    /// HA servers status into the status-get response.
+    data::ConstElementPtr processStatusGet() const;
+
 protected:
 
     /// @brief Starts asynchronous heartbeat to a peer.
diff --git a/src/hooks/dhcp/high_availability/tests/communication_state_unittest.cc b/src/hooks/dhcp/high_availability/tests/communication_state_unittest.cc
index 6213d87afe..46441ec3a1 100644
--- a/src/hooks/dhcp/high_availability/tests/communication_state_unittest.cc
+++ b/src/hooks/dhcp/high_availability/tests/communication_state_unittest.cc
@@ -22,6 +22,7 @@
 
 using namespace isc;
 using namespace isc::asiolink;
+using namespace isc::data;
 using namespace isc::dhcp;
 using namespace isc::ha;
 using namespace isc::ha::test;
@@ -102,7 +103,42 @@ TEST_F(CommunicationStateTest, partnerState) {
 
     // An attempt to set unsupported value should result in exception.
     EXPECT_THROW(state_.setPartnerState("unsupported"), BadValue);
+}
 
+// Verifies that the partner's scopes are set and retrieved correctly.
+TEST_F(CommunicationStateTest, partnerScopes) {
+    // Initially, the scopes should be empty.
+    ASSERT_TRUE(state_.getPartnerScopes().empty());
+
+    // Set new partner scopes.
+    ASSERT_NO_THROW(
+        state_.setPartnerScopes(Element::fromJSON("[ \"server1\", \"server2\" ]"))
+    );
+
+    // Get them back.
+    auto returned = state_.getPartnerScopes();
+    EXPECT_EQ(2, returned.size());
+    EXPECT_EQ(1, returned.count("server1"));
+    EXPECT_EQ(1, returned.count("server2"));
+
+    // Override the scopes.
+    ASSERT_NO_THROW(
+        state_.setPartnerScopes(Element::fromJSON("[ \"server1\" ]"))
+    );
+    returned = state_.getPartnerScopes();
+    EXPECT_EQ(1, returned.size());
+    EXPECT_EQ(1, returned.count("server1"));
+
+    // Clear the scopes.
+    ASSERT_NO_THROW(
+        state_.setPartnerScopes(Element::fromJSON("[ ]"))
+    );
+    returned = state_.getPartnerScopes();
+    EXPECT_TRUE(returned.empty());
+
+    // An attempt to set invalid JSON should fail.
+    EXPECT_THROW(state_.setPartnerScopes(Element::fromJSON("{ \"not-a-list\": 1 }")),
+                 BadValue);
 }
 
 // Verifies that the object is poked right after construction.
diff --git a/src/hooks/dhcp/high_availability/tests/ha_impl_unittest.cc b/src/hooks/dhcp/high_availability/tests/ha_impl_unittest.cc
index 9285181cec..8d2a7e48cd 100644
--- a/src/hooks/dhcp/high_availability/tests/ha_impl_unittest.cc
+++ b/src/hooks/dhcp/high_availability/tests/ha_impl_unittest.cc
@@ -535,5 +535,53 @@ TEST_F(HAImplTest, continueHandler) {
     checkAnswer(response, CONTROL_RESULT_SUCCESS, "HA state machine is not paused.");
 }
 
+// Tests status-get command processed handler.
+TEST_F(HAImplTest, statusGet) {
+    HAImpl ha_impl;
+    ASSERT_NO_THROW(ha_impl.configure(createValidJsonConfiguration()));
+
+    // Starting the service is required prior to running any callouts.
+    NetworkStatePtr network_state(new NetworkState(NetworkState::DHCPv4));
+    ASSERT_NO_THROW(ha_impl.startService(io_service_, network_state,
+                                         HAServerType::DHCPv4));
+
+    std::string name = "status-get";
+    ConstElementPtr response =
+        Element::fromJSON("{ \"arguments\": { \"pid\": 1 }, \"result\": 0 }");
+
+    CalloutHandlePtr callout_handle = HooksManager::createCalloutHandle();
+
+    callout_handle->setArgument("name", name);
+    callout_handle->setArgument("response", response);
+
+    ASSERT_NO_THROW(ha_impl.commandProcessed(*callout_handle));
+
+    ConstElementPtr got;
+    callout_handle->getArgument("response", got);
+    ASSERT_TRUE(got);
+
+    std::string expected =
+        "{"
+        "    \"arguments\": {"
+        "        \"ha-servers\": {"
+        "            \"local\": {"
+        "                \"role\": \"primary\","
+        "                \"scopes\": [  ],"
+        "                \"state\": \"waiting\""
+        "            },"
+        "            \"remote\": {"
+        "                \"age\": 0,"
+        "                \"in-touch\": false,"
+        "                \"last-scopes\": [ ],"
+        "                \"last-state\": \"\","
+        "                \"role\": \"secondary\""
+        "            }"
+        "        },"
+        "        \"pid\": 1"
+        "    },"
+        "    \"result\": 0"
+        "}";
+    EXPECT_TRUE(isEquivalent(got, Element::fromJSON(expected)));
+}
 
 }
diff --git a/src/hooks/dhcp/high_availability/tests/ha_service_unittest.cc b/src/hooks/dhcp/high_availability/tests/ha_service_unittest.cc
index 225fbe2175..fe6e94b516 100644
--- a/src/hooks/dhcp/high_availability/tests/ha_service_unittest.cc
+++ b/src/hooks/dhcp/high_availability/tests/ha_service_unittest.cc
@@ -40,6 +40,7 @@
 #include <gtest/gtest.h>
 #include <functional>
 #include <sstream>
+#include <set>
 #include <string>
 #include <vector>
 
@@ -1065,6 +1066,25 @@ TEST_F(HAServiceTest, hotStandbyScopeSelectionThisPrimary) {
     service.verboseTransition(HA_HOT_STANDBY_ST);
     service.runModel(HAService::NOP_EVT);
 
+    // Check the reported info about servers.
+    ConstElementPtr ha_servers = service.processStatusGet();
+    ASSERT_TRUE(ha_servers);
+    std::string expected = "{"
+        "    \"local\": {"
+        "        \"role\": \"primary\","
+        "        \"scopes\": [ \"server1\" ],"
+        "        \"state\": \"hot-standby\""
+        "    }, "
+        "    \"remote\": {"
+        "        \"age\": 0,"
+        "        \"in-touch\": false,"
+        "        \"role\": \"standby\","
+        "        \"last-scopes\": [ ],"
+        "        \"last-state\": \"\""
+        "    }"
+        "}";
+    EXPECT_TRUE(isEquivalent(Element::fromJSON(expected), ha_servers));
+
     // Set the test size - 65535 queries.
     const unsigned queries_num = 65535;
     for (unsigned i = 0; i < queries_num; ++i) {
@@ -1093,6 +1113,26 @@ TEST_F(HAServiceTest, hotStandbyScopeSelectionThisStandby) {
     // ... and HA service using this configuration.
     TestHAService service(io_service_, network_state_, config_storage);
 
+    // Check the reported info about servers.
+    ConstElementPtr ha_servers = service.processStatusGet();
+    ASSERT_TRUE(ha_servers);
+
+    std::string expected = "{"
+        "    \"local\": {"
+        "        \"role\": \"standby\","
+        "        \"scopes\": [ ],"
+        "        \"state\": \"waiting\""
+        "    }, "
+        "    \"remote\": {"
+        "        \"age\": 0,"
+        "        \"in-touch\": false,"
+        "        \"role\": \"primary\","
+        "        \"last-scopes\": [ ],"
+        "        \"last-state\": \"\""
+        "    }"
+        "}";
+    EXPECT_TRUE(isEquivalent(Element::fromJSON(expected), ha_servers));
+
     // Set the test size - 65535 queries.
     const unsigned queries_num = 65535;
     for (unsigned i = 0; i < queries_num; ++i) {
@@ -1599,7 +1639,8 @@ TEST_F(HAServiceTest, processHeartbeat) {
     HAConfigParser parser;
     ASSERT_NO_THROW(parser.parse(config_storage, Element::fromJSON(config_text)));
 
-    HAService service(io_service_,  network_state_, config_storage);
+    TestHAService service(io_service_,  network_state_, config_storage);
+    service.query_filter_.serveDefaultScopes();
 
     // Process heartbeat command.
     ConstElementPtr rsp;
@@ -1622,6 +1663,15 @@ TEST_F(HAServiceTest, processHeartbeat) {
     ASSERT_TRUE(date_time);
     EXPECT_EQ(Element::string, date_time->getType());
 
+    auto scopes_list = args->get("scopes");
+    ASSERT_TRUE(scopes_list);
+    EXPECT_EQ(Element::list, scopes_list->getType());
+    ASSERT_EQ(1, scopes_list->size());
+    auto scope = scopes_list->get(0);
+    ASSERT_TRUE(scope);
+    EXPECT_EQ(Element::string, scope->getType());
+    EXPECT_EQ("server1", scope->stringValue());
+
     // The response should contain the timestamp in the format specified
     // in RFC1123. We use the HttpDateTime method to parse this timestamp.
     HttpDateTime t;
@@ -2547,7 +2597,7 @@ public:
               const TestHttpResponseCreatorFactoryPtr& factory,
               const std::string& initial_state = "waiting")
         : listener_(listener), factory_(factory), running_(false),
-          static_date_time_() {
+          static_date_time_(), static_scopes_() {
         transition(initial_state);
     }
 
@@ -2566,6 +2616,13 @@ public:
         static_date_time_ = static_date_time;
     }
 
+    /// @brief Sets static scopes to be used in responses.
+    ///
+    /// @param scopes Fixed scopes set.
+    void setScopes(const std::set<std::string>& scopes) {
+        static_scopes_ = scopes;
+    }
+
     /// @brief Enable response to commands required for leases synchronization.
     ///
     /// Enables dhcp-disable, dhcp-enable and lease4-get-page commands. The last
@@ -2615,6 +2672,13 @@ public:
         if (!static_date_time_.empty()) {
             response_arguments->set("date-time", Element::create(static_date_time_));
         }
+        if (!static_scopes_.empty()) {
+            auto json_scopes = Element::createList();
+            for (auto scope : static_scopes_) {
+                json_scopes->add(Element::create(scope));
+            }
+            response_arguments->set("scopes", json_scopes);
+        }
         factory_->getResponseCreator()->setArguments(response_arguments);
     }
 
@@ -2634,6 +2698,9 @@ private:
 
     /// @brief Static date-time value to be returned.
     std::string static_date_time_;
+
+    /// @brief Static scopes to be reported.
+    std::set<std::string> static_scopes_;
 };
 
 /// @brief Shared pointer to a partner.
@@ -3012,7 +3079,9 @@ TEST_F(HAServiceStateMachineTest, waitingParterDownLoadBalancingPartnerDown) {
     EXPECT_EQ(HA_PARTNER_DOWN_ST, service_->getCurrState());
 
     // Partner shows up and (eventually) transitions to READY state.
-    HAPartner partner(listener2_, factory2_, "ready");
+    HAPartner partner(listener2_, factory2_);
+    partner.setScopes({ "server1", "server2" });
+    partner.transition("ready");
     partner.startup();
 
     // PARTNER DOWN state: receive a response from the partner indicating that
@@ -3024,6 +3093,42 @@ TEST_F(HAServiceStateMachineTest, waitingParterDownLoadBalancingPartnerDown) {
     ASSERT_FALSE(isCommunicationInterrupted());
     ASSERT_FALSE(isFailureDetected());
 
+    // Check the reported info about servers.
+    ConstElementPtr ha_servers = service_->processStatusGet();
+    ASSERT_TRUE(ha_servers);
+
+    // Hard to know what is the age of the remote data. Therefore, let's simply
+    // grab it from the response.
+    ASSERT_EQ(Element::map, ha_servers->getType());
+    auto remote = ha_servers->get("remote");
+    ASSERT_TRUE(remote);
+    EXPECT_EQ(Element::map, remote->getType());
+    auto age = remote->get("age");
+    ASSERT_TRUE(age);
+    EXPECT_EQ(Element::integer, age->getType());
+    auto age_value = age->intValue();
+    EXPECT_GE(age_value, 0);
+
+    // Now append it to the whole structure for comparison.
+    std::ostringstream s;
+    s << age_value;
+
+    std::string expected = "{"
+        "    \"local\": {"
+        "        \"role\": \"primary\","
+        "        \"scopes\": [ \"server1\", \"server2\" ], "
+        "        \"state\": \"load-balancing\""
+        "    }, "
+        "    \"remote\": {"
+        "        \"age\": " + s.str() + ","
+        "        \"in-touch\": true,"
+        "        \"role\": \"secondary\","
+        "        \"last-scopes\": [ \"server1\", \"server2\" ],"
+        "        \"last-state\": \"ready\""
+        "    }"
+        "}";
+    EXPECT_TRUE(isEquivalent(Element::fromJSON(expected), ha_servers));
+
     // Crash the partner and see whether our server can return to the partner
     // down state.
     partner.setControlResult(CONTROL_RESULT_ERROR);
diff --git a/src/lib/dhcpsrv/cfgmgr.cc b/src/lib/dhcpsrv/cfgmgr.cc
index 69f1b314c3..a9394efc3f 100644
--- a/src/lib/dhcpsrv/cfgmgr.cc
+++ b/src/lib/dhcpsrv/cfgmgr.cc
@@ -108,6 +108,10 @@ CfgMgr::commit() {
         }
     }
 
+    // Set the last commit timestamp.
+    auto now = boost::posix_time::second_clock::universal_time();
+    configuration_->setLastCommitTime(now);
+
     // Now we need to set the statistics back.
     configuration_->updateStatistics();
 }
diff --git a/src/lib/dhcpsrv/tests/cfgmgr_unittest.cc b/src/lib/dhcpsrv/tests/cfgmgr_unittest.cc
index ecfe7fccc9..f81931a97a 100644
--- a/src/lib/dhcpsrv/tests/cfgmgr_unittest.cc
+++ b/src/lib/dhcpsrv/tests/cfgmgr_unittest.cc
@@ -461,12 +461,19 @@ TEST_F(CfgMgrTest, staging) {
 
     // This should change the staging configuration so as it becomes a current
     // one.
+    auto before = boost::posix_time::second_clock::universal_time();
     cfg_mgr.commit();
+    auto after = boost::posix_time::second_clock::universal_time();
     const_config = cfg_mgr.getCurrentCfg();
     ASSERT_TRUE(const_config);
     // Sequence id equal to 1 indicates that the current configuration points
     // to the configuration that used to be a staging configuration previously.
     EXPECT_EQ(1, const_config->getSequence());
+    // Last commit timestamp should be between before and after.
+    auto reload = const_config->getLastCommitTime();
+    ASSERT_FALSE(reload.is_not_a_date_time());
+    EXPECT_LE(before, reload);
+    EXPECT_GE(after, reload);
 
     // Create a new staging configuration. It should be assigned a new
     // sequence id.
diff --git a/src/lib/process/config_base.h b/src/lib/process/config_base.h
index a2380f0e5c..1a99d4c99f 100644
--- a/src/lib/process/config_base.h
+++ b/src/lib/process/config_base.h
@@ -12,6 +12,7 @@
 #include <process/config_ctl_info.h>
 #include <process/logging_info.h>
 #include <util/optional.h>
+#include <boost/date_time/posix_time/posix_time.hpp>
 
 namespace isc {
 namespace process {
@@ -134,6 +135,18 @@ public:
         return (server_tag_);
     }
 
+    /// @brief Returns the last commit timestamp.
+    /// @return the last commit timestamp.
+    boost::posix_time::ptime getLastCommitTime() const {
+        return (last_commit_time_);
+    }
+
+    /// @brief Sets the last commit timestamp.
+    /// @param last_commit_time last commit timestamp.
+    void setLastCommitTime(const boost::posix_time::ptime& last_commit_time) {
+        last_commit_time_ = last_commit_time;
+    }
+
 protected:
     /// @brief Copies the current configuration to a new configuration.
     ///
@@ -154,6 +167,9 @@ private:
 
     /// @brief Logical name of the server
     util::Optional<std::string> server_tag_;
+
+    /// @brief Stores the last commit timestamp.
+    boost::posix_time::ptime last_commit_time_;
 };
 
 /// @brief Non-const pointer to the @c ConfigBase.
diff --git a/src/lib/process/d_cfg_mgr.cc b/src/lib/process/d_cfg_mgr.cc
index 43596f9974..318860751f 100644
--- a/src/lib/process/d_cfg_mgr.cc
+++ b/src/lib/process/d_cfg_mgr.cc
@@ -99,6 +99,9 @@ DCfgMgrBase::simpleParseConfig(isc::data::ConstElementPtr config_set,
                     post_config_cb();
                 }
                 LOG_INFO(dctl_logger, DCTL_CONFIG_COMPLETE).arg(getConfigSummary(0));
+                // Set the last commit timestamp.
+                auto now = boost::posix_time::second_clock::universal_time();
+                context_->setLastCommitTime(now);
             } else {
                 rollback = true;
             }
diff --git a/src/lib/process/d_controller.cc b/src/lib/process/d_controller.cc
index 18e8de242c..83db472b94 100644
--- a/src/lib/process/d_controller.cc
+++ b/src/lib/process/d_controller.cc
@@ -135,6 +135,9 @@ DControllerBase::launch(int argc, char* argv[], const bool test_mode) {
                    << comment->stringValue());
     }
 
+    // Note that the controller was started.
+    start_ = boost::posix_time::second_clock::universal_time();
+
     // Everything is clear for launch, so start the application's
     // event loop.
     try {
@@ -636,6 +639,26 @@ DControllerBase::serverTagGetHandler(const std::string&, ConstElementPtr) {
     return (createAnswer(COMMAND_SUCCESS, response));
 }
 
+ConstElementPtr
+DControllerBase::statusGetHandler(const std::string&, ConstElementPtr) {
+    ElementPtr status = Element::createMap();
+    status->set("pid", Element::create(static_cast<int>(getpid())));
+
+    auto now = boost::posix_time::second_clock::universal_time();
+    if (!start_.is_not_a_date_time()) {
+        auto uptime = now - start_;
+        status->set("uptime", Element::create(uptime.total_seconds()));
+    }
+
+    auto last_commit = process_->getCfgMgr()->getContext()->getLastCommitTime();
+    if (!last_commit.is_not_a_date_time()) {
+        auto reload = now - last_commit;
+        status->set("reload", Element::create(reload.total_seconds()));
+    }
+
+    return (createAnswer(COMMAND_SUCCESS, status));
+}
+
 ConstElementPtr
 DControllerBase::versionGetHandler(const std::string&, ConstElementPtr) {
     ConstElementPtr answer;
diff --git a/src/lib/process/d_controller.h b/src/lib/process/d_controller.h
index 6fbbb7c6ac..2b9849a87d 100644
--- a/src/lib/process/d_controller.h
+++ b/src/lib/process/d_controller.h
@@ -123,9 +123,10 @@ public:
     /// 1. parse command line arguments
     /// 2. instantiate and initialize the application process
     /// 3. load the configuration file
-    /// 4. initialize signal handling
-    /// 5. start and wait on the application process event loop
-    /// 6. exit to the caller
+    /// 4. record the start timestamp
+    /// 5. initialize signal handling
+    /// 6. start and wait on the application process event loop
+    /// 7. exit to the caller
     ///
     /// It is intended to be called from main() and be given the command line
     /// arguments.
@@ -340,6 +341,19 @@ public:
     serverTagGetHandler(const std::string& command,
                         isc::data::ConstElementPtr args);
 
+    /// @brief handler for status-get command
+    ///
+    /// This method handles the status-get command, which retrieves
+    /// the server process information i.e. the pid and returns it in
+    /// response.
+    ///
+    /// @param command (ignored)
+    /// @param args (ignored)
+    /// @return process information wrapped in a response
+    isc::data::ConstElementPtr
+    statusGetHandler(const std::string& command,
+                     isc::data::ConstElementPtr args);
+
 protected:
     /// @brief Virtual method that provides derivations the opportunity to
     /// support additional command line options.  It is invoked during command
diff --git a/src/lib/process/d_process.h b/src/lib/process/d_process.h
index f5de80c46a..e0e429d343 100644
--- a/src/lib/process/d_process.h
+++ b/src/lib/process/d_process.h
@@ -52,6 +52,9 @@ static const std::string SERVER_TAG_GET_COMMAND("server-tag-get");
 /// @brief String value for the shutdown command.
 static const std::string SHUT_DOWN_COMMAND("shutdown");
 
+/// @brief String value for the status-get command.
+static const std::string STATUS_GET_COMMAND("status-get");
+
 /// @brief Returned by the process to indicate a command was successful.
 static const int COMMAND_SUCCESS = 0;
 
@@ -134,7 +137,7 @@ public:
     /// Certainly once during process startup, and possibly later if the user
     /// alters configuration. This method must not throw, it should catch any
     /// processing errors and return a success or failure answer as described
-    /// below.
+    /// below. On success the last commit timestamp must be updated.
     ///
     /// @param config_set a new configuration (JSON) for the process
     /// @param check_only true if configuration is to be verified only, not applied
diff --git a/src/lib/process/daemon.h b/src/lib/process/daemon.h
index 8b8c24d612..d8786ff6e6 100644
--- a/src/lib/process/daemon.h
+++ b/src/lib/process/daemon.h
@@ -12,6 +12,7 @@
 #include <util/pid_file.h>
 #include <util/signal_set.h>
 #include <boost/noncopyable.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
 #include <string>
 
 namespace isc {
@@ -260,6 +261,9 @@ protected:
     /// @brief Manufacture the pid file name
     std::string makePIDFileName() const;
 
+    /// @brief Timestamp of the start of the daemon.
+    boost::posix_time::ptime start_;
+
 private:
     /// @brief Config file name or empty if config file not used.
     std::string config_file_;
diff --git a/src/lib/process/testutils/d_test_stubs.cc b/src/lib/process/testutils/d_test_stubs.cc
index f0b7ad70b2..a310824669 100644
--- a/src/lib/process/testutils/d_test_stubs.cc
+++ b/src/lib/process/testutils/d_test_stubs.cc
@@ -1,4 +1,4 @@
-// Copyright (C) 2013-2018 Internet Systems Consortium, Inc. ("ISC")
+// Copyright (C) 2013-2019 Internet Systems Consortium, Inc. ("ISC")
 //
 // This Source Code Form is subject to the terms of the Mozilla Public
 // License, v. 2.0. If a copy of the MPL was not distributed with this
-- 
2.16.4

